## Файлові Системи (ФС)

### Визначення та Роль Файлової Системи

Файлова система (ФС) є фундаментальною архітектурною складовою будь-якої операційної системи (ОС). Вона являє собою не просто спосіб зберігання даних, а **організаційну структуру** та набір правил, які дозволяють ОС ефективно керувати даними на пристроях довготривалого зберігання, таких як жорсткі диски (HDD), твердотільні накопичувачі (SSD) та флеш-носії. Основна роль ФС полягає у забезпеченні **абстракції**: для користувача та прикладних програм дані представлені у вигляді логічних іменованих об'єктів — **файлів**, тоді як ФС відповідає за їхнє фізичне розміщення, пошук та адресацію на носії. Фактично, ФС виступає як глобальний **індекс** або **каталог**, який перетворює логічні запити на доступ до файлу в точні фізичні команди для пристрою. Без файлової системи простір на диску був би лише безструктурним потоком бітів, що зробило б неможливим ідентифікацію та відновлення окремих частин інформації.

### Базові Компоненти ФС

Для виконання своїх функцій файлова система оперує кількома основними структурними елементами. **Файл** — це іменована сукупність даних, яка розглядається як єдине ціле. Кожен файл має набір **атрибутів** (метаданих), які включають ім'я, розмір, часові мітки (створення, зміна, доступ) і, критично важливо, **початкову адресу** його даних на диску. **Каталог** (або папка) є особливим типом файлу, який не містить даних користувача, а слугує для зберігання посилань (записів) на інші файли та каталоги. Це дозволяє створювати **ієрархічну (деревоподібну) структуру** , що робить організацію даних інтуїтивно зрозумілою та масштабованою. Фізично на носії дані виділяються порціями, які називаються **блоками** або **кластерами**. Кластер — це найменша одиниця простору, яку ФС може виділити для зберігання частини файлу. Усі ці елементи описуються **метаданими** — даними про самі дані, які зберігаються у службових областях диска і є ключем до швидкого доступу та відновлення інформації.

### Ефективність, Надійність та Журнальовані ФС

Ефективність файлової системи оцінюється швидкістю доступу та ефективністю використання дискового простору. Розмір кластера, наприклад, впливає на **внутрішню фрагментацію** (марно витрачений простір в останньому кластері файлу). Проте, у сучасних умовах, надійність та **цілісність даних** є пріоритетом. Збій живлення або аварійне завершення роботи ОС під час запису файлу може призвести до неконсистентного стану ФС, коли метадані частково оновлені, а самі дані — ні (або навпаки), що викликає втрату інформації. Для боротьби з цим були розроблені **журнальовані ФС (Journaling File Systems)**, такі як NTFS (Windows) або ext4 (Linux). Принцип журналювання полягає в тому, що перед внесенням фактичних змін до даних, ФС спочатку записує опис цієї операції у спеціальну область — **журнал**. Якщо система дає збій, при наступному завантаженні ОС перевіряє журнал. Це дозволяє або **завершити** незавершену операцію (redo), або **відкотити** її (undo), гарантуючи, що файлова система завжди повертається до консистентного стану. Це значно скорочує час відновлення після збою та підвищує загальну надійність зберігання.

## Специфіка ФС у Unix-подібних Операційних Системах

### Філософія "Все є файл"

Фундаментальною архітектурною особливістю Unix-подібних операційних систем (таких як Linux, macOS, BSD) є принцип **"Все є файл"** (`Everything is a file`). Ця філософія забезпечує уніфікований та простий інтерфейс для взаємодії з різними системними ресурсами. Це означає, що, окрім звичайних файлів даних і каталогів, такі об'єкти, як пристрої вводу/виводу (наприклад, принтери, клавіатура), мережеві сокети, та навіть деякі системні процеси, представлені в ієрархії файлової системи як спеціальні типи файлів. Наприклад, доступ до першого жорсткого диска здійснюється через файл пристрою `/dev/sda`, а інформація про запущені процеси доступна через псевдо-файлову систему `/proc`. Такий підхід значно спрощує розробку програмного забезпечення, оскільки більшість операцій, будь то читання з диска чи отримання даних із мережі, можуть бути виконані за допомогою стандартних системних викликів, призначених для роботи з файлами.

### Архітектура Unix ФС та i-node

На відміну від систем, де кожен фізичний диск має свій кореневий каталог (наприклад, літери дисків у Windows), Unix-подібні системи використовують **єдине кореневе дерево каталогів**, що починається з `/` (root). Всі фізичні розділи, мережеві ресурси та зовнішні пристрої **монтуються** (приєднуються) до певних точок цього єдиного дерева. Ключовою структурою, яка забезпечує цю архітектуру, є **i-node** (індексний дескриптор). Кожен файл і каталог на диску має унікальний **i-node**, який зберігає всю критичну **метаінформацію** про файл: тип файлу, розмір, права доступу, ідентифікатори власника та групи, часові мітки та, найголовніше, **адреси фізичних блоків даних** файлу на диску. Критично важливо розуміти, що **i-node не містить імені файлу**. Ім'я файлу (або кілька імен) зберігається лише в каталозі разом із посиланням на відповідний i-node. Це дозволяє легко створювати **жорсткі посилання (hard links)** — різні записи в різних каталогах, які вказують на один і той самий i-node та, відповідно, на той самий набір даних. 

### Керування Доступом: Користувачі, Групи та Права

Безпека та ізоляція даних у Unix-подібних системах забезпечується моделлю **Дискреційного Керування Доступом (DAC)**, яка ґрунтується на концепції **користувачів** та **груп**. Кожен файл має лише одного **власника** (ідентифікованого за UID) та одну **власницьку групу** (ідентифіковану за GID). Користувачі можуть належати до кількох груп. Права доступу є набором дозволів, які присвоюються незалежно для трьох категорій суб'єктів: **Власник** (`u` - user), **Група** (`g` - group) та **Інші** (`o` - others). Кожна категорія може мати дозволи на **Читання** (`r` - 4), **Запис** (`w` - 2) та **Виконання** (`x` - 1). Права часто представляються у **вісімковій нотації**, де кожне число від 0 до 7 є сумою дозволів для однієї категорії. Наприклад, `750` означає: Власник має повні права (4+2+1=7), Група має читання та виконання (4+1=5), а Інші не мають жодних прав (0). Керування цими дозволами здійснюється за допомогою утиліт командного рядка: **`chmod`** (зміна дозволів) та **`chown`** (зміна власника/групи). 

---

## Навігація та Пошук у Unix-подібних ФС

### Утиліта `find` — Пошук Файлів за Атрибутами

Утиліта командного рядка **`find`** є одним із найпотужніших та найгнучкіших інструментів у Unix-подібних системах, призначеним для пошуку файлів та каталогів в ієрархії файлової системи, починаючи від заданої точки. На відміну від простих пошукових механізмів, які шукають лише за іменем, `find` дозволяє формувати складні критерії пошуку, ґрунтуючись на метаданих файлу, які зберігаються в **i-node**. Базовий синтаксис команди включає шлях початку пошуку, а потім один або кілька виразів (критеріїв). 

Пошук можна здійснювати за великою кількістю критеріїв:
* **За іменем:** Використовуючи опції `-name` або `-iname` (без врахування регістру).
* **За типом:** Наприклад, `-type f` (звичаний файл), `-type d` (каталог), `-type l` (символічне посилання).
* **За розміром:** Використовуючи `-size` з префіксами (наприклад, `+10M` для файлів, більших за 10 мегабайт, або `-1k` для менших за 1 кілобайт).
* **За часом модифікації:** Використовуючи `-mtime` (кількість днів з моменту модифікації) або `-mmin` (кількість хвилин).
* **За правами доступу:** Використовуючи `-perm`, наприклад, `-perm 755` для точного пошуку файлів з цими правами.
* **За власником/групою:** Використовуючи `-user` або `-group`.

Особлива потужність `find` полягає у можливості **виконання дій** над знайденими файлами. Для цього використовується опція **`-exec`**, яка дозволяє запускати зовнішню команду для кожного знайденого об'єкта. Це дає змогу автоматизувати складні операції, такі як архівування, зміна прав доступу або видалення файлів, які відповідають певним, дуже специфічним умовам. Наприклад, можна знайти всі файли логів, які не змінювалися понад 30 днів, і автоматично їх заархівувати або видалити, що є критично важливим для системного адміністрування.

---

## Архіватори та Алгоритми Стиснення

### Призначення Стиснення та Надлишковість Даних

Стиснення даних є фундаментальною технологією, основною метою якої є зменшення обсягу даних без втрати (або з мінімальною втратою) інформації. Цей процес ґрунтується на концепції **надлишковості (redundancy)**. Більшість даних, незалежно від їхнього типу (текст, зображення, код), містять повторювані елементи, послідовності або візерунки. Наприклад, у текстовому документі певні літери або слова зустрічаються частіше, ніж інші, а в зображенні можуть бути великі однотонні області. Алгоритми стиснення розроблені для того, щоб виявити цю надлишковість і замінити довгі або часті послідовності на більш короткі **коди** або **посилання**. Це дозволяє економити дисковий простір та значно прискорювати передачу даних через мережу, що особливо критично для великих файлів та Інтернет-трафіку.

### Типи Стиснення та Алгоритми

Алгоритми стиснення поділяються на дві основні категорії, залежно від того, чи зберігається початкова інформація при відновленні.

**Стиснення Без Втрат (Lossless Compression):**
Цей метод гарантує, що відновлені дані будуть **абсолютно ідентичними** оригіналу, біт у біт. Він є обов'язковим для файлів, де втрата навіть одного біта може бути критичною, таких як текстові документи, програмний код, бази даних та наукові дані. Ключові алгоритми стиснення без втрат, як-от **Хафман (Huffman Coding)**, призначають коротші коди (послідовності бітів) символам, які зустрічаються частіше, та довші — рідкісним, оптимізуючи загальну довжину файлу. Інший клас алгоритмів, заснований на **LZ77 / LZ78 (Lempel-Ziv)**, шукає повторювані послідовності байтів у даних і замінює їх посиланнями на попередні входження цих послідовностей, ефективно створюючи динамічний **словник** під час обробки. [Image comparing Huffman coding and Lempel-Ziv dictionary approach]

**Стиснення З Втратами (Lossy Compression):**
Цей метод досягає значно вищих коефіцієнтів стиснення шляхом **видалення** тієї частини інформації, яка, на думку алгоритму, є менш важливою або непомітною для кінцевого користувача (людини). Відновлення до оригіналу, відповідно, **неможливе**. Стиснення з втратами використовується майже виключно для мультимедійних даних, де невелике зниження якості часто є прийнятним в обмін на мінімальний розмір файлу. Наприклад, формати **JPEG** для зображень використовують **дискретне косинусне перетворення (DCT)**, щоб перетворити дані у частотну область і відкинути високочастотні деталі, які людське око сприймає гірше. Аудіоформати, такі як **MP3**, використовують моделі **психоакустики** для виявлення та видалення звуків, які будуть замасковані більш гучними звуками або є поза межами сприйняття.

### Інструменти Пакування та Стиснення: tar, zip/unzip

У контексті роботи з файловими системами часто використовують спеціалізовані утиліти, які поєднують функції **пакування (архівування)** та **стиснення**.

**1. Утиліта `tar` (Tape ARchive):**
`tar` є класичною Unix-утилітою, яка історично використовувалася для запису на магнітні стрічки. Її основна функція — **пакування**: об'єднання кількох файлів або цілих каталогів із збереженням їхньої ієрархічної структури, метаданих, прав доступу та власників, в **один файл** (який називають **tarball**). Сам по собі `tar` не виконує стиснення. Для зменшення розміру tarball його зазвичай "пропускають" через окремий алгоритм стиснення, наприклад `gzip` (створюючи `.tar.gz` або `.tgz`) або `bzip2` (`.tar.bz2`).
* *Приклад команди:* `tar -cvzf archive.tar.gz /path/to/directory` (де `-z` викликає `gzip`).

**2. Формат ZIP та Утиліти `zip`/`unzip`:**
Формат `ZIP` і відповідні утиліти (`zip`/`unzip`) стали найбільш поширеним кросплатформним стандартом для обміну архівами. На відміну від `tar`, утиліта `zip` **виконує обидві функції одночасно**: пакує декілька файлів і стискає їх, зазвичай використовуючи алгоритм, заснований на Lempel-Ziv (LZ77). Завдяки інтегрованому підходу та повсюдній підтримці в усіх операційних системах, ZIP є зручним рішенням, коли ключовою вимогою є портативність та сумісність.
* *Приклад команди:* `zip -r archive.zip /path/to/directory` (де `-r` означає рекурсивне включення каталогу).