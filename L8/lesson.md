### Shell Scripting

Посилання на веб машину

> https://webvm.io/alpine.html

Супер документація
> https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html

#### Вступ

BASH — це акронім, що розшифровується як Bourne Again Shell. Він базується на оболонці Bourne і переважно сумісний з її можливостями.

Оболонки (Shells) — це інтерпретатори команд. Це додатки, які надають користувачам можливість давати команди своїй операційній системі інтерактивно або швидко виконувати пакети команд. Вони жодним чином не є обов'язковими для виконання програм; вони — лише шар між системними викликами функцій та користувачем.

Думайте про оболонку як про спосіб вашого спілкування з системою. Вашій системі вона не потрібна для більшої частини роботи, але вона є чудовим інтерфейсом між вами та тим, що система може запропонувати. Вона дозволяє виконувати базові математичні обчислення, проводити прості тести та запускати додатки. Що ще важливіше, вона дозволяє комбінувати ці операції та з'єднувати додатки між собою для виконання складних та автоматизованих завдань.

BASH — це не ваша операційна система. Це не ваш віконний менеджер. Це не ваш термінал (але він часто запускається всередині вашого термінала). Він не керує вашою мишею чи клавіатурою. Він не налаштовує вашу систему, не активує заставку екрана і не відкриває файли, коли ви двічі клацаєте по них. Зазвичай він не задіяний у запуску додатків із вашого віконного менеджера чи робочого столу.

Важливо розуміти, що BASH — це лише інтерфейс для виконання вами інструкцій (використовуючи синтаксис BASH) або через інтерактивний рядок запиту BASH, або через BASH-скрипти.

### Використання Bash'у

Більшість користувачів, коли думають про BASH, уявляють його як рядок запиту (prompt) та командний рядок. Це — BASH в інтерактивному режимі. BASH також може працювати в неінтерактивному режимі, наприклад, під час виконання скриптів.

Ми можемо використовувати скрипти для автоматизації певної логіки. Скрипти — це, по суті, списки команд (точно таких самих, які ви можете вводити в командному рядку), але збережені у файлі. Коли скрипт запускається, всі ці команди (зазвичай) виконуються послідовно, одна за одною.

Ми почнемо з основ в інтерактивній оболонці. Щойно ви опануєте їх, ви зможете об'єднувати їх у скрипти.

Традиційно рядок запиту оболонки закінчується символами $, % або #.

- Якщо він закінчується на $, це вказує на оболонку, сумісну з Bourne shell (наприклад, POSIX shell, Korn shell або Bash).

- Якщо він закінчується на %, це вказує на C shell (csh або tcsh); цей посібник не розглядає C shell.

- Якщо він закінчується на #, це означає, що оболонка запущена від імені суперкористувача системи (root), і вам слід бути надзвичайно обережними.

Ваш реальний рядок запиту BASH, ймовірно, буде набагато довшим за просте $. Рядки запиту часто є дуже індивідуальними.

Команда man означає «**man**ual» (посібник); вона відкриває документацію (так звані «man pages») на різні теми. Ви використовуєте її, запускаючи команду man [тема] у рядку BASH, де [тема] — це назва «сторінки», яку ви хочете прочитати. Зауважте, що багато з цих «сторінок» значно довші за одну друковану сторінку, проте назва зберігається. Кожна команда (додаток) у вашій системі, ймовірно, має свою сторінку man. Існують сторінки і для інших речей, наприклад, для системних викликів або специфічних конфігураційних файлів. У цьому посібнику ми розглядатимемо лише команди.

Зверніть увагу: якщо ви шукаєте інформацію про вбудовані функції BASH (команди, що надаються самим BASH, а не зовнішніми додатками), вам слід зазирнути в man bash. Посібник BASH є дуже об'ємним і детальним. Це чудове довідкове джерело, хоча воно й більш технічне, ніж цей посібник.

Bash також пропонує команду help, яка містить короткі описи його вбудованих команд.

### Команди та аргументи

BASH зчитує команди зі свого вводу (яким зазвичай є або термінал, або файл). Кожен зчитаний рядок вводу розглядається як команда — інструкція, яку необхідно виконати. (Існує кілька складніших випадків, наприклад, команди, що охоплюють кілька рядків, але ми розглянемо їх пізніше).

Bash розділяє кожен рядок на слова, які розмежовуються символами пробілу (пробіли та табуляція). Перше слово в рядку — це назва команди, яку потрібно виконати. Усі інші слова стають аргументами цієї команди (опції, імена файлів тощо).

Припустимо, ми перебуваємо в порожній директорії

```bash
# Для створення папки
$ mkdir test
$ cd test
```

```bash
$ ls
$ touch f ff fff
$ ls
```

Команда ls виводить назви файлів у поточній директорії. Коли ми запускаємо команду списку вперше, ми не отримуємо жодного результату, оскільки файлів ще немає.

Символ # на початку слова позначає коментар. Усі слова, що йдуть після коментаря, ігноруються оболонкою і призначені лише для читання людиною. Якщо ми запускаємо ці приклади у власній оболонці, нам не обов'язково друкувати коментарі; але навіть якщо ми це зробимо, команда все одно працюватиме.

touch — це додаток, який змінює час останньої модифікації (Last Modified) файлу. Якщо ім'я файлу, яке йому передали, ще не існує, він створює файл із такою назвою як новий і порожній файл. У цьому прикладі ми передали три аргументи. touch створює файл для кожного аргументу. ls показує нам, що було створено три файли.

```bash
$ rm *
$ ls
$ touch f   ff fff
$ ls
```

rm — це додаток, який видаляє всі файли, які йому було передано. * (зірочка) — це підстановочний знак (glob). Він фактично означає «все», і в даному випадку — всі файли в поточній директорії. Ми детальніше поговоримо про «глоби» пізніше.

Тепер, чи помітили ми, що між f та ff є кілька пробілів, а між ff та fff — лише один? Також зверніть увагу, що файли, створені командою touch, нічим не відрізняються від створених першого разу. Кількість пробілів між аргументами не має значення! Це важливо знати.

```bash
$ echo This is a test.
$ echo This    is    a    test.
```

echo — це команда, яка виводить свої аргументи у стандартний вивід (яким у нашому випадку є термінал). У цьому прикладі ми передаємо команді echo чотири аргументи: 'This', 'is', 'a' та 'test.'. echo бере ці аргументи і виводить їх один за одним, розділяючи пробілом.

У другому випадку відбувається те саме. Зайві пробіли не мають значення. Якщо ми хочемо зберегти додаткові пробіли, нам потрібно передати речення як один єдиний аргумент. Ми можемо зробити це за допомогою лапок.

```bash
$ echo "This    is    a    test."
```

Лапки групують усе, що знаходиться всередині них, в один єдиний аргумент. У нашому випадку аргументом стає: 'This is a test.'... із конкретно заданими пробілами. Зверніть увагу, що самі лапки не є частиною аргументу — Bash видаляє їх перед тим, як передати цей аргумент команді echo. Команда echo виводить цей єдиний аргумент точно так само, як вона робить це зазвичай.

Будьте дуже обережні, щоб уникати наступного:

```bash
$ ls                                          # У нас є два файли
The secret voice in your head.mp3  secret
$ rm The secret voice in your head.mp3        # Видаляє 6 файлів
rm: cannot remove `The': No such file or directory
rm: cannot remove `voice': No such file or directory
rm: cannot remove `in': No such file or directory
rm: cannot remove `your': No such file or directory
rm: cannot remove `head.mp3': No such file or directory
$ ls                                          # Подивимося що залишилося
The secret voice in your head.mp3             # secret був видалений
```

Ми повинні переконатися, що правильно беремо імена файлів у лапки. Якщо ми цього не зробимо, ми можемо випадково видалити зовсім не те, що планували!

rm приймає імена файлів як аргументи. Якщо імена наших файлів містять пробіли і ми не беремо їх у лапки, Bash вважає, що кожне слово — це окремий аргумент. Bash передає кожен аргумент програмі rm окремо. Наче індивідуально загорнуті скибочки плавленого сиру, rm сприймає кожен аргумент як окремий файл.

У наведеному вище прикладі rm намагався видалити окремий файл для кожного слова в назві пісні, замість того, щоб зберегти ім'я файлу цілісним. Це призвело до того, що наш файл secret було видалено, а пісня залишилася на місці!

Ось як ми мали б це зробити:

```bash
$ rm "The secret voice in your head.mp3"
```

Аргументи відокремлюються від назви команди та один від одного за допомогою пробілів (whitespace). Це важливо пам'ятати. Наприклад, наступний запис є неправильним:

```bash
$ [-f file]
bash: [-f: command not found
```

Це призначено для перевірки існування файлу з назвою "file". Цілком логічно припустити, що пробіли навколо [ та ] не мають значення, але насправді [ — це окрема команда, і вона вимагає, щоб її останнім аргументом був символ ]. (Ми розглянемо команду [ детальніше пізніше).

Отже, ми обов'язково повинні відокремити [ від -f та ] від назви файлу пробілами. В іншому випадку Bash подумає, що ми намагаємося виконати команду з назвою [-f з єдиним аргументом file]. Правильна команда відокремлює всі аргументи пробілами:

```bash
$ [ -f file ]
```

І якщо ім'я нашого файлу містить пробіли або інші спеціальні символи, воно також має бути взяте в лапки:

```bash
$ [ -f "my file" ]
```